#include "codegen_functions.h"

/* ------------------------------------------------------------- */
/*                         System Templates                      */
/* ------------------------------------------------------------- */

/* Generated code Header */
const char mips_header[] = 
    "# ### START OF GENERATED CODE ### #\n"
    "\n"
    "# Code Generated By Jeferson Lima and Jeferson Rene Compiler\n"
    "# LUA MIPS Compiler Version 0.3 \n"
    "\n"
    "# Variable Declarations\n"
    ".data\n"
    "\n"
    "# System default variables \n"
    GLOBAL_SYSTEM_VARIABLE_PREFIX "newline: .asciiz \"\\n\"\n"
    GLOBAL_SYSTEM_VARIABLE_PREFIX "nil_str: .asciiz \"nil\"\n"
    GLOBAL_SYSTEM_VARIABLE_PREFIX "nil_val: .word   " NIL_TYPE_VALUE "\n"
    "\n"
    "# User Global Variables\n";

/* -- GLOBAL VARS -- */

/* System Functions */        
const char mips_main[] =
    "\n# Start of mips code\n"
    ".globl main\n"
    ".text\n"
    "\n"
    "# -- Main Definition -- #\n"
    "main:\n"
    "\n";
    
/* -- ALL INSTRUCTIONS -- "%s" */

/* Close main */
const char mips_footer[] =
    "\n"
    "# Close Main Declaration\n"
    "end_main:\n"
        "\tli $v0, 10\n"
        "\tsyscall\n"
    "\n"
    "# -- End of Main -- #\n"
    "\n"
    "# System Defined Functions\n"
    "\n"
    "# -- Print Function -- #\n"
    "function_print:\n"
        "\t# Load Function Frame Pointer and Return Adress\n"
        "\tmove $fp, $sp\n"
        "\tsw $ra, 0($sp)\n"
        "\taddiu $sp, $sp, 4\n"
        "\n"
        "\t# Load First Parameter\n"
        "\tlw $a0, 4($fp)\n"
        "\n"
        "\t# Check if it's a nil number\n"
        "\tli $t1, " NIL_TYPE_MASK "\n"
        "\txor $t0, $a0, $t1\n"
        "\tnot $t0, $t0\n"
        "\tbeq $t0, $0, print_nil_value\n"
        "\n"
        "\t# Print number if it's not nil\n"
        "\tli $v0, 1\n"
        "\tsyscall\n"
        "\tj end_print\n"
        "\n"
    "print_nil_value:\n"
        "# Print Value nil\n"
        "\tli $v0, 4\n"
        "\tla $a0, _nil_str\n"
        "\tsyscall\n"
        "\n"
    "end_print:\n"
        "\t# Print linefeed\n"
        "\tli $v0, 4\n"
        "\tla $a0, _newline\n"
        "\tsyscall\n"
        "\n"
        "\t# Close Print Function \n"
        "\tlw $ra, 0($fp)\n"
        "\taddiu $sp, $sp, 12\n"
        "\tlw $fp, 0($sp)\n"
        "\tjr $ra\n"
    "# -- End Print Function -- #\n"
    "\n"
    "# ### END OF GENERATED CODE ### #\n";

/* ------------------------------------------------------------- */
/*                   Basic Instructions Template                 */
/* ------------------------------------------------------------- */

/* Define a global variable */    
const char mips_global_define[] =
    "# ----------- Define a global variable ---------- #\n"
    "" GLOBAL_VARIABLE_PREFIX "%s .word " NIL_TYPE_VALUE "\n"
    "# ----------------------------------------------- #\n";

/* Define a local variable */    
const char mips_local_define[] =
    "\t# ------------ Define a local variable ---------- #\n"
    "\taddiu $sp, $sp, -4\n"
    "\t# ----------------------------------------------- #\n";

/* Store a global variable */    
const char mips_global_store[] =
    "\t# --------- Store $a0 in global variable -------- #\n"
    "\tsw $a0, " GLOBAL_VARIABLE_PREFIX "%s\n"
    "\t# ----------------------------------------------- #\n";

/* Load a global variable into $a0 */
const char mips_global_load[] =
    "\t# --------- Load global variable in $a0 --------- #\n"
    "\tlw $a0, " GLOBAL_VARIABLE_PREFIX "%s\n"
    "\t# ----------------------------------------------- #\n";

/* Store a local variable */    
const char mips_local_store[] =
    "\t# --------- Store $a0 in local variable --------- #\n"
    "\tsw $a0, %d($sp)\n"
    "\t# ----------------------------------------------- #\n";

/* Load a local variable into $a0 */
const char mips_local_load[] =
    "\t# --------- Load local variable in $a0 ---------- #\n"
    "\tlw $a0, %d($sp)\n"
    "\t# ----------------------------------------------- #\n";

/* Push temporary return of a expression */
const char mips_push_a0[] =
    "\t# -------------- Push $a0 to stack -------------- #\n"
    "\tsw $a0, 0($sp)\n"
    "\taddiu $sp, $sp, -" TO_STRING(BYTE_VARIABLE_SIZE) "\n"
    "\t# ----------------------------------------------- #\n";
    
/* Pop stack value */
const char mips_pop[] =
    "\t# ------------------- Pop stack ----------------- #\n"
    "\taddiu $sp, $sp, " TO_STRING(BYTE_VARIABLE_SIZE) "\n"
    "\t# ----------------------------------------------- #\n";

/* Load top value to $t1 */
const char mips_top_t1[] =
    "\t# ------------- Top of stack to $t1 ------------- #\n"
    "\tlw $t1, " TO_STRING(BYTE_VARIABLE_SIZE) "($sp)\n"
    "\t# ----------------------------------------------- #\n";

/* Load a static number into $a0 */
const char mips_static_number_load[] =
    "\t# --------- Load static number into $a0 --------- #\n"
    "\tli $a0, %s\n"
    "\t# ----------------------------------------------- #\n";

/* ------------------------------------------------------------- */
/*                  Unary Operations Template                    */
/* ------------------------------------------------------------- */

/**
 * Model for unary operations
 * 
 *  Default Model:
 *      CGEN(operand exp) ->
 *          CGEN(exp)
 *          CGEN(operand)
 */

/* Not a number in $a0 */
const char mips_not_a0[] =
    "\t# ---------------- Not $a0 number --------------- #\n"
    "\tnot $a0, $a0\n"
    "\t# ----------------------------------------------- #\n";
 
/* Convert $a0 to a negative number */
const char mips_neg_a0[] =
    "\t# ---------------- Neg $a0 number --------------- #\n"
    "\tnegu $a0, $a0\n"
    "\t# ----------------------------------------------- #\n";

/* ------------------------------------------------------------- */
/*                  Binary Operations Template                   */
/* ------------------------------------------------------------- */

/**
 * Model for binary operations
 * 
 *  Default Model:
 *      CGEN(exp1 operand exp2) ->
 *          CGEN(exp1)
 *          push_a0
 *          CGEN(exp2)
 *          top_t1
 *          CGEN(operand)
 *          pop
 */

/* Add value of $t1 with $a0 and store in $a0 */
const char mips_add_a0_t1_a0[] =
    "\t# ------------- Add $a0 = $t1 + $a0 ------------- #\n"
    "\tadd $a0, $t1, $a0\n"
    "\t# ----------------------------------------------- #\n";
    
/* Sub value of $t1 with $a0 and store in $a0 */
const char mips_sub_a0_t1_a0[] =
    "\t# ------------- Sub $a0 = $t1 - $a0 ------------- #\n"
    "\tsub $a0, $t1, $a0\n"
    "\t# ----------------------------------------------- #\n";
    
/* Div value of $t1 with $a0 and store in $a0 */
const char mips_div_a0_t1_a0[] =
    "\t# ------------- Div $a0 = $t1 / $a0 ------------- #\n"
    "\tdiv $a0, $t1, $a0\n"
    "\t# ----------------------------------------------- #\n";

/* Mul value of $t1 with $a0 and store in $a0 */
const char mips_mul_a0_t1_a0[] =
    "\t# ------------- Mul $a0 = $t1 * $a0 ------------- #\n"
    "\tmul $a0, $t1, $a0\n"
    "\t# ----------------------------------------------- #\n";

/* And the value of $t1 with $a0 and store in $a0 */
const char mips_and_a0_t1_a0[] =
    "\t# ------------- And $a0 = $t1 && $a0 ------------ #\n"
    "\tand $a0, $t1, $a0\n"
    "\t# ----------------------------------------------- #\n";
    
/* Or the value of $t1 with $a0 and store in $a0 */
const char mips_or_a0_t1_a0[] =
    "\t# ------------- Or $a0 = $t1 || $a0 ------------- #\n"
    "\tor $a0, $t1, $a0\n"
    "\t# ----------------------------------------------- #\n";

/* Check if is greater than, the value of $t1 with $a0 and store in $a0 */
const char mips_gt_a0_t1_a0[] =
    "\t# ------------- Gt $a0 = $t1 > $a0 -------------- #\n"
    "\tslt $a0, $a0, $t1\n"
    "\t# ----------------------------------------------- #\n";

/* Check if is less than, the value of $t1 with $a0 and store in $a0 */
const char mips_lt_a0_t1_a0[] =
    "\t# ------------- Lt $a0 = $t1 < $a0 -------------- #\n"
    "\tslt $a0, $t1, $a0\n"
    "\t# ----------------------------------------------- #\n";

/* Check if $a0 is equal $t1 */
const char mips_eq_a0_t1_a0[] =
    "\t# ------------- Eq $a0 = $t1 == $a0 ------------- #\n"
    "\tsubu $a0, $t1, $a0\n"
    "\tsltu $a0, $0, $a0\n"
    "\txori $a0, $a0, 1\n"
    "\t# ----------------------------------------------- #\n";

/* Check if $a0 is not equal $t1 */
const char mips_neq_a0_t1_a0[] =
    "\t# ------------- Neq $a0 = $t1 ~= $a0 ------------ #\n"
    "\tsubu $a0, $t1, $a0\n"
    "\tsltu $a0, $0, $a0\n"
    "\t# ----------------------------------------------- #\n";

/* Check if $a0 is greater or equal $t1 */
const char mips_gte_a0_t1_a0[] =
    "\t# ------------- Gte $a0 = $t1 >= $a0 ------------ #\n"
    "\tslt $a0, $t1, $a0\n"
    "\txori $a0, $a0, 1\n"
    "\t# ----------------------------------------------- #\n";
    
/* Check if $a0 is less or equal $t1 */
const char mips_lte_a0_t1_a0[] =
    "\t# ------------- Lte $a0 = $t1 <= $a0 ------------ #\n"
    "\tslt $a0, $a0, $t1\n"
    "\txori $a0, $a0, 1\n"
    "\t# ----------------------------------------------- #\n";

/* ------------------------------------------------------------- */
/*               Conditional Operations Template                 */
/* ------------------------------------------------------------- */

/**
 * Model for conditional operations
 * 
 *  Default Model:
 *      CGEN(if exp_list1 then block1 {elseif exp_list2 then bloco_i} [else block2] end) ->
 *          CGEN(exp_list1)          
 *          beq $a0, $0, end_if_n_exp_i
 *          CGEN(block1)
 *          j end_if_n
 *          end_if_n_exp_i:
 *          {
 *              CGEN(exp_list2)
 *              beq $a0, $0, end_if_n_exp_(i + 1)
 *              CGEN(bloco_i)
 *              j end_if_n
 *              end_if_n_exp_(i + 1):
 *          }+
 *          [
 *              CGEN(block2)
 *          ]*
 *          end_if_n:
 */
    
/* Conditional type If-elseif-else */
const char mips_start_if[] =
    "\t# -------------------- If ----------------------- #\n";

/* Check if condition */
const char mips_check_if[] =
    "\tbeq $a0, $0, end_if_%d_exp_%d\n";

/* Check the next if condition */
const char mips_next_if[] =
    "\tj end_if_%d\n"
    "end_if_%d_exp_%d:\n";

/* If end condition */
const char mips_end_if[] =
    "end_if_%d:\n"
    "\t# ----------------------------------------------- #\n";
 
/* ------------------------------------------------------------- */
/*                      While Loop Template                      */
/* ------------------------------------------------------------- */

/**
 * Model for while loop operations.
 * 
 *     Default Model While:
 *        CGEN(while(exp1) do bloco end) ->
 *          start_while_n:
 *          CGEN(exp1)
 *          beq $a0, $0, end_while_n
 *          CGEN(bloco)
 *          b start_while_n
 *          end_while_n:
 *
 */

/* Loop type while */
const char mips_start_while[] =
    "\t# -------------------- While -------------------- #\n"
    "start_while_%d:\n";

/* While loop check while condition */
const char mips_check_while[] =
    "\tbeq $a0, $0, end_while_%d\n";

/* While end loop */
const char mips_end_while[] =
    "\tb start_while_%d\n"
    "end_while_%d:\n"
    "\t# ----------------------------------------------- #\n";

/* ------------------------------------------------------------- */
/*                       For Loop Template                       */
/* ------------------------------------------------------------- */

/**
 * Model for 'for' loop operations.
 *
 *  Exemplo com sintax c-like
 *  for(x = exp; x <= exp; x += [exp] | 1)
 * 
 *  | > INICIALIZACAO, CONDICAO, INCREMENTO
 * 
 *     Default Model for:
 *          CGEN(for name = exp_ini, exp_cond [, exp_inc] do block end)
 *              CGEN(ASSIGN(local name = exp_ini))
 *              start_for_n:
 *              CGEN(exp_cond)
 *              beq $a0, $0, end_for_n
 *              CGEN(block)
 *              CGEN(exp_inc) | li $a0, 1
 *              lw $t1, $a0
 *              CGEN(name)        -- esse cara carrega o valor do name que inicializamos no come√ßo
 *              add $a0, $a0, $t1 -- executa a expressao normal jogar em a0 se for default faz li $a0, 1
 *              CGEN(name = $a0)  -- esse salva de novo
 *              j start_for_n
 *              end_for_n:
 * 
 */

/* Loop type for */
const char mips_for_ini[] =
    "\t# ---------------------- For -------------------- #\n";

/* Begin of for */
const char mips_start_for[] =
    "start_for_%d:\n";

/* For condition check */
const char mips_for_con[] =
    "\tbeq $a0, $0, end_for_%d\n";
    
/* Store */
const char mips_for_load_inc[] =
    "\tlw $t1, $a0\n";

/* Mips default for inc */
const char mips_for_inc[] =
    "\tadd $a0, $a0, $t1\n";

/* End of for defition */
const char mips_end_for[]=
    "\tj start_for_%d"
    "end_for_%d:\n"
    "\t# ----------------------------------------------- #\n";

/* ------------------------------------------------------------- */
/*                    Function Definitions                       */
/* ------------------------------------------------------------- */

/**
 * Model for function call.
 * 
 * x = newSymbolTable(NULL)
 * for param in x1, ..., xn
 *      addSymbolNode(x, x1)
 * 
 * x - 4
 * y - 8
 * z - 12
 * 
 * u = 0
 * k(0, 1, 2)
 * 
 * 0 - 4
 * 1 - 8
 * 2 - 12
 * 
 * function k(x, y, z)
 *      local t = 0
 *      print(x)
 * end
 * 
 *  Default Model for functions declaration:
 *      CGEN(function f(x1, ..., xn) bloco end)
 *          move $fp, $sp
 *          sw $ra, 0($sp)
 *          addiu $sp, $sp, -4
 *          CGEN(bloco)
 *          lw $ra, 4($sp)
 *          addiu $sp, $sp, z
 *          lw $fp, 0($sp)
 *          jr $ra
 * 
 */

/* Start of function definition */
const char mips_start_function_def[] =
    "\t# ------------- Function Definition ------------- #\n"
    "\tmove $fp, $sp\n"
    "\tsw $ra, 0($sp)\n"
    "\taddiu $sp, $sp, -4\n";

/* End of function definition */
const char mips_end_function_def[] =
    "\tlw $ra, 0($fp)\n"
    "\taddiu $sp, $sp, %d\n"
    "\tlw $fp, 0($sp)\n"
    "\tjr $ra\n"
    "\t# ----------------------------------------------- #\n";

/* ------------------------------------------------------------- */
    
/* ------------------------------------------------------------- */
/*                        Function Calls                         */
/* ------------------------------------------------------------- */

/**
 * Model for function call.
 * 
 *  Default Model CGEN(function_name(listexp[a,b,...])):
 *      CGEN(listexp[1])
 *      push $a0
 *      CGEN(listexp[2])
 *      push $a0
 *      ...
 *      jal function_name
 */
 const char mips_start_function_call[] =
    "\t# ---------------- Call Function ---------------- #\n"
    "\tsw $fp, 0($sp)\n"
    "\taddiu $sp, $sp, -4\n";
    
const char mips_end_function_call[] =
    "\tjal function_%s\n"
    "\t# ----------------------------------------------- #\n";

/* ------------------------------------------------------------- */

/* ------------------------------------------------------------- */
/*                      Nil type definition                      */
/* ------------------------------------------------------------- */

/**
 * Model for nil numbers.
 * 
 *  Default Model CGEN(nil):
 *      lw $a0, _nil_val
 * 
 *  Description:
 *      Nil values is interpreted as the last signed number or 
 *      0x7FFFFFFF this number represent the number 0x0 after
 *      a xor with the mask 0x80000000 and a bitwise negation
 *      if this value is used it will interpreted as a nil number
 * 
 *  Warning:
 *      Operations should test if this number can be subtracted,
 *      multiplied, addition and division is possible but should
 *      be avoided as much as it's possible.
 */

/* ------------------------------------------------------------- */

/* Load a nil into $a0 */
const char mips_nil[] =
    "\t# --------- Load global variable in $a0 --------- #\n"
    "\tlw $a0, " GLOBAL_VARIABLE_PREFIX "nil_val\n"
    "\t# ----------------------------------------------- #\n";
 
/* ------------------------------------------------------------- */
/*                  ..........................                   */
/* ------------------------------------------------------------- */

/**
 * Model ...
 * 
 *  Default Model:
 *      ...
 */